# Number

数字数据类型用于存储数值。他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。当你指定一个值时，Number对象就会被创建

Python3中提供的数字数据类型包含以下四种类型：

- int（有符号整型）
- float（浮点型）
- complex（复数）

## 目录

- [int](#int)
  - [int的范围](#int的范围)
- [Float](#Float)
  - [float的精度控制](#float的精度控制)
  - [float的取整](#float的取整)
- [Complex](#Complex)
- [算术运算](#算术运算)
- [Number按位逻辑运算](#Number按位逻辑运算)
  - [“`&`”按位与运算](#“`&`”按位与运算)
  - [“`|`”按位或运算](#“`|`”按位或运算)
  - [“`^`”按位异或运算](#“`^`”按位异或运算)
  - [“`~`”按位取反运算](#“`~`”按位取反运算)
  - [“`>>`”按位右移运算](#“`>>`”按位右移运算)
  - [“`<<`”按位左移运算](#“`<<`”按位左移运算)
- [Number类型之间的转换](#Number类型之间的转换)

## int

Integer是Python中的int类型，是有Int类来实现的。其中：</br>

- Python 2中有int类型和long类型,在 2.2 以后的版本中，int 类型数据溢出后会自动转为long类型
- Python 3中只有int类型

### int的范围

- Python 2.x:</br>
  - 32位：-2^31\~2^31-1 </br>
  - 64位：-2^63\~2^63-1 </br>
- Python 3.x:</br>
  - 无上限

## Float

浮点数是用机器上浮点数的本机双精度(64 bit)表示的。提供大约17位的精度和范围从-308到308的指数。和C语言里面的double类型相同。Python不支持32bit的单精度浮点数。如果程序需要精确控制区间和数字精度，可以考虑使用numpy扩展库。

Python 3.X对于浮点数默认的是提供17位数字的精度。

关于单精度和双精度的通俗解释：

单精度型和双精度型，其类型说明符为float 单精度说明符，double 双精度说明符。在Turbo C中单精度型占4个字节（32位）内存空间，其数值范围为3.4E-38～3.4E+38，只能提供七位有效数字。双精度型占8 个字节（64位）内存空间，其数值范围为1.7E-308～1.7E+308，可提供16位有效数字。

### float的精度控制

- 内置函数round()
- 格式化输出，16位小数，超了之后不再准确，没有意义
- 高精度使用decimal模块，配合getcontext

### float的取整

- round
- math模块的ceil(x)：大于或者等于的最小整数
- math模块的floor(x)：小于或者大于的最大整数

```python
>>> from math import ceil, floor
>>> round(2.5)
2
>>> ceil(2.5)
3
>>> floor(2.5)
2
>>> round(2.3)
2
>>> ceil(2.3)
3
>>> floor(2.3)
2
```

## Complex

复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型。

## 算术运算

| 表达式 | 解释 |
| ----- | ---- |
| + | 加法运算 |
| - | 减法运算 |
| \* | 乘法运算 |
| / | 除法运算 |
| // | 整除运算 |
| % | 求模/取余运算 |
| \*\* | 幂运算 |

## Number按位逻辑运算

位运算符：位运算符是把数字转成二进制来进行计算的，有以下几种运算规则：

- “`&`”按位与运算
- “`|`”按位或运算
- “`^`”按位异或运算
- “`~`”按位取反运算
- “`>>`”按位右移运算
- “`<<`”按位左移运算

<!-- - [“`&`”按位与运算](#“`&`”按位与运算)
- [“`|`”按位或运算](#“`|`”按位或运算)
- [“`^`”按位异或运算](#“`^`”按位异或运算)
- [“`~`”按位取反运算](#“`~`”按位取反运算)
- [“`>>`”按位右移运算](#“`>>`”按位右移运算)
- [“`<<`”按位左移运算](#“`<<`”按位左移运算) -->

### “`&`”按位与运算

两个对应的二进制为，如果两个二进位都为1，则该位结果为1，否则为0

- 一一为一，其余为零

实例：

```py
>>> bin(10)
'0b1010'
>>> bin(9)
'0b1001'
>>> 0b1010 & 0b1001
8
>>> bin(8)
'0b1000'
>>>
```

### “`|`”按位或运算

两个对应的二进制为，最少一个为1，则为1，否则为0。

- 零零为零，其余为一

实例：

```py
>>> 0b10&0b1
0
>>> bin(10)
'0b1010'
>>> bin(9)
'0b1001'
>>> 0b1010 | 0b1001
11
>>> bin(11)
'0b1011'
>>>
```

### “`^`”按位异或运算

两个对应的二进制为，两个值相同时，返回false，否则返回true。也就是说，XOR可以用来判断两个值是否不同，用于加密

- 相同为零，反之则一

```py
>>> 0b10&0b1
0
>>> bin(10)
'0b1010'
>>> bin(9)
'0b1001'
>>> 0b1010 ^ 0b1001
3
>>> bin(3)
'0b11'
>>>
```

### “`~`”按位取反运算

按位取反运算符，用来对一个二进制数按位取反，即将0变1，将1变0，按理说十进制的5（0000 0101）按位取反应该为（1111 1010）十进制250，但是在Python中运算结果并非如此，结果如下：

```py
>>> ~-6
5
```

计算机中的符号数有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。
正整数的补码是其二进制表示，与原码相同 。
负整数的补码，将其对应正数二进制表示所有位取反（包括符号位，0变1，1变0）后加1。
Python按位取反运算：

```py
>>> ~-6
5
```

运算分析：
-6的补码是+6（0000 0110）取反后再+1,为（1111 1001）+（0000 0001）=（1111 1010）,
，也就是计算机中-6是用(1111 1010)来存储的,(1111 1010) 按位取反得到(0000 0101)这就是答案5

### “`>>`”按位右移运算

将一个数字转换成二进制，然后右移x位，相当于，从右往左砍掉x位，剩下的就是返回值。

***注意：***

- 负数不能进行移位运算，会抛出一个`ValueError`的异常。

```py
>>> bin(10)
'0b1010'
>>> 10>>3
1
>>> bin(1)
'0b1'
>>>
```

### “`<<`”按位左移运算

将一个数字转换成二进制，然后左移x位，就是在最右边补充x个0，然后将得到的结果返回

```py
>>> bin(10)
'0b1010'
>>> 10<<3
80
>>>
```

## Number类型之间的转换

| 表达式 | 解释 |
| ----- | ---- |
| int(x [,base ])         | 将x转换为一个整数  
| long(x [,base ])        | 将x转换为一个长整数  
| float(x )               | 将x转换到一个浮点数  
| complex(real [,imag ])  | 创建一个复数  
| str(x )                 | 将对象 x 转换为字符串  
| repr(x )                | 将对象 x 转换为表达式字符串  
| eval(str )              | 用来计算在字符串中的有效Python表达式,并返回一个对象  
| tuple(s )               | 将序列 s 转换为一个元组  
| list(s )                | 将序列 s 转换为一个列表  
| chr(x )                 | 将一个整数转换为一个字符  
| unichr(x )              | 将一个整数转换为Unicode字符  
| ord(x )                 | 将一个字符转换为它的整数值  
| hex(x )                 | 将一个整数转换为一个十六进制字符串  
| oct(x )                 | 将一个整数转换为一个八进制字符串